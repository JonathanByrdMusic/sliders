<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Three Sliders · Web Audio</title>
  <style>
    :root { --gap: 1rem; --track-h: 6px; --thumb: 18px; }
    html, body { height: 100%; }
    body {
      margin: 0; font: 16px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      display: grid; place-items: start center; background:#0b0b0d; color:#eaeaea;
    }
    .wrap { width: min(900px, 92vw); margin-top: 5vh; }
    h1 { font-size: 1.25rem; margin: 0 0 var(--gap); }
    .row { display:flex; align-items:center; gap:var(--gap); margin: calc(var(--gap) * 1.0) 0; }
    label { width: 16ch; font-weight: 600; }
    output { width: 6ch; text-align: right; }
    input[type="range"]{ flex:1; appearance:none; height:var(--track-h); border-radius:999px; background:#2a2a2e; outline:none; }
    input[type="range"]::-webkit-slider-thumb{ appearance:none; width:var(--thumb); height:var(--thumb); border-radius:50%; background:#eaeaea; cursor:pointer; margin-top: calc((var(--track-h) - var(--thumb)) / 2); }
    input[type="range"]::-moz-range-thumb{ width:var(--thumb); height:var(--thumb); border:none; border-radius:50%; background:#eaeaea; cursor:pointer; }
    input[type="range"]::-moz-range-track{ height:var(--track-h); background:#2a2a2e; border:none; }
    .controls { display:flex; gap:.75rem; flex-wrap:wrap; margin: .5rem 0 1rem; }
    button { cursor:pointer; border:0; padding:.6rem .9rem; border-radius:.8rem; background:#eaeaea; color:#0b0b0d; font-weight:600; }
    button.secondary { background:#2a2a2e; color:#eaeaea; }
    .note { opacity:.8; font-size:.9rem; }
  </style>
</head>
<body>
  <main class="wrap" aria-label="Above the fold sliders controlling audio">
    <h1>Three sliders controlling a Web Audio tone</h1>

    <div class="controls">
      <button id="startBtn">Start tone</button>
      <button id="stopBtn" class="secondary">Stop</button>
    </div>

    <div class="row">
      <label for="sMorph">Wave morph (saw → sine)</label>
      <input id="sMorph" type="range" min="0" max="200" step="1" value="0" />
      <output id="oMorph">0</output>
    </div>

    <div class="row">
      <label for="sHarm">Harmonics (0 → 10)</label>
      <input id="sHarm" type="range" min="0" max="200" step="1" value="20" />
      <output id="oHarm">1</output>
    </div>

    <div class="row">
      <label for="sVerb">Reverb mix (dry → wet)</label>
      <input id="sVerb" type="range" min="0" max="200" step="1" value="0" />
      <output id="oVerb">0%</output>
    </div>

    <p class="note">Click <strong>Start tone</strong> to begin audio.</p>
  </main>

  <script>
  // ====== Globals ======
  let ctx, master, dryGain, wetGain, reverb,
      sinOsc, sawOsc, gainSine, gainSaw,
      harmonics = [], harmonicGains = [];
  const BASE_FREQ = 220;
  const NUM_HARMONICS_MAX = 10;

  // --- iOS unlock: prime the audio hardware with a tiny silent buffer ---
  async function unlockAudio() {
    if (!ctx) return;
    if (ctx.state === 'running') return;
    try {
      const buffer = ctx.createBuffer(1, 1, ctx.sampleRate);
      const src = ctx.createBufferSource();
      src.buffer = buffer;
      src.connect(ctx.destination);
      src.start(0);
      await ctx.resume();
    } catch (e) {
      // ignore
    }
  }

  // --- Build the node graph (no oscillators started yet) ---
  function setupGraph() {
    ctx = new (window.AudioContext || window.webkitAudioContext)();

    master  = ctx.createGain(); master.gain.value = 0.25;
    dryGain = ctx.createGain(); wetGain = ctx.createGain();
    dryGain.gain.value = 1.0;   wetGain.gain.value = 0.0;

    reverb = ctx.createConvolver();
    reverb.buffer = createReverbImpulse(ctx, 2.2, 4.0);

    // these gains will host the morphing sources
    gainSine = ctx.createGain(); gainSine.gain.value = 0.0;
    gainSaw  = ctx.createGain(); gainSaw.gain.value  = 1.0;

    // Harmonic gains
    for (let k = 2; k <= NUM_HARMONICS_MAX + 1; k++) {
      const g = ctx.createGain();
      g.gain.value = 0.0;
      harmonicGains.push(g);
    }

    // Sum -> dry/wet -> master -> destination
    const drySum = ctx.createGain();
    gainSine.connect(drySum);
    gainSaw.connect(drySum);
    harmonicGains.forEach(g => g.connect(drySum));

    drySum.connect(dryGain);
    drySum.connect(reverb);
    reverb.connect(wetGain);

    dryGain.connect(master);
    wetGain.connect(master);
    master.connect(ctx.destination);
  }

  // --- Create and start sources AFTER context is running (iOS-friendly) ---
  function startSourcesIfNeeded() {
    if (sinOsc) return; // already started

    sinOsc = ctx.createOscillator();
    sinOsc.type = 'sine';
    sinOsc.frequency.value = BASE_FREQ;
    sinOsc.connect(gainSine);

    sawOsc = ctx.createOscillator();
    sawOsc.type = 'sawtooth';
    sawOsc.frequency.value = BASE_FREQ;
    sawOsc.connect(gainSaw);

    harmonics = [];
    for (let k = 2; k <= NUM_HARMONICS_MAX + 1; k++) {
      const o = ctx.createOscillator();
      o.type = 'sine';
      o.frequency.value = BASE_FREQ * k;
      o.connect(harmonicGains[k - 2]);
      harmonics.push(o);
    }

    sinOsc.start();
    sawOsc.start();
    harmonics.forEach(o => o.start());
  }

  // --- Reverb impulse (same as before) ---
  function createReverbImpulse(context, seconds = 2.0, decay = 3.0) {
    const rate = context.sampleRate;
    const length = Math.max(1, Math.floor(seconds * rate));
    const impulse = context.createBuffer(2, length, rate);
    for (let ch = 0; ch < 2; ch++) {
      const data = impulse.getChannelData(ch);
      for (let i = 0; i < length; i++) {
        const t = i / length;
        data[i] = (Math.random() * 2 - 1) * Math.pow(1 - t, decay);
      }
    }
    return impulse;
  }

  // ====== UI wiring & parameter updates (unchanged logic) ======
  const sMorph = document.getElementById('sMorph');
  const sHarm  = document.getElementById('sHarm');
  const sVerb  = document.getElementById('sVerb');
  const oMorph = document.getElementById('oMorph');
  const oHarm  = document.getElementById('oHarm');
  const oVerb  = document.getElementById('oVerb');

  function updateMorph(v) {
    const x = Math.max(0, Math.min(1, v / 200));
    const sine = Math.sin(0.5 * Math.PI * x);
    const saw  = Math.cos(0.5 * Math.PI * x);
    if (gainSine && gainSaw) {
      const t = ctx.currentTime;
      gainSine.gain.setTargetAtTime(sine, t, 0.01);
      gainSaw.gain.setTargetAtTime(saw,  t, 0.01);
    }
    oMorph.textContent = (x * 100).toFixed(0) + '%';
  }

  function updateHarmonics(v) {
    const n = Math.round((v / 200) * NUM_HARMONICS_MAX);
    oHarm.textContent = String(n);
    if (!harmonicGains.length) return;
    const t = ctx.currentTime;
    harmonicGains.forEach((g, i) => {
      const k = i + 2;
      const target = (i < n) ? (0.25 / k) : 0.0;
      g.gain.setTargetAtTime(target, t, 0.02);
    });
  }

  function updateReverb(v) {
    const x = Math.max(0, Math.min(1, v / 200));
    const wet = Math.sin(0.5 * Math.PI * x);
    const dry = Math.cos(0.5 * Math.PI * x);
    const t = ctx.currentTime;
    wetGain.gain.setTargetAtTime(wet, t, 0.02);
    dryGain.gain.setTargetAtTime(dry, t, 0.02);
    oVerb.textContent = Math.round(x * 100) + '%';
  }

  sMorph.addEventListener('input', e => updateMorph(+e.target.value));
  sHarm.addEventListener('input',  e => updateHarmonics(+e.target.value));
  sVerb.addEventListener('input',  e => updateReverb(+e.target.value));

  const start = async () => {
    if (!ctx) setupGraph();
    await unlockAudio();          // <- important on iOS
    if (ctx.state !== 'running') await ctx.resume();
    startSourcesIfNeeded();       // <- start oscillators now that audio is running
    // sync params to current sliders
    updateMorph(+sMorph.value);
    updateHarmonics(+sHarm.value);
    updateReverb(+sVerb.value);
  };

  const stop = async () => {
    if (ctx && ctx.state === 'running') await ctx.suspend();
  };

  // Buttons + iOS touchstart
  const startBtn = document.getElementById('startBtn');
  const stopBtn  = document.getElementById('stopBtn');
  startBtn.addEventListener('click', start);
  startBtn.addEventListener('touchstart', (e) => { e.preventDefault(); start(); }, {passive:false});
  stopBtn.addEventListener('click', stop);
  stopBtn.addEventListener('touchstart', (e) => { e.preventDefault(); stop(); }, {passive:false});
</script>
</body>
</html>
